This project is adapted from https://github.com/Tierion/merkle-tools .
The purpose is to generate Merkle trees, calculate the proofs, and validate the data.

Compare with original code, apart from removing some features, the main differences of this code are:
* Only use `keccak256` hash function (require [ethereumjs-util](https://github.com/ethereumjs/ethereumjs-util))
* Sort the leaves by using the hash of transactions (the original [merkle-tools](https://github.com/Tierion/merkle-tools)
sort by the sequence while adding the leaves)

# Brief intro
See the example:

    const MerkleTree = require('merkle.js');
    let merkleTree = new MerkleTree();
    merkleTree.addLeaf(keccak256('a'));  // give a hash (in the form of hex Buffer)
    merkleTree.addLeaf('b', True);  // tell the addLeaf() to make a hash
    merkleTree.addLeaves(['c', 'd', 'e'], True);  // add multiple leaves, need to make hashes

    merkleTree.makeTree();  // Now the tree is ready

    let mroot = merkleTree.getMerkleRoot();
    let proof = merkleTree.getProof(2);  // all the proofs require to validate leave of index 2
    let target = merkleTree.getLeaf(2);
    let isValid = merkleTree.validateProof(proof, target, mroot);  // should be true here


# How to validate a tx?

           [root]         level 0
            / \      
            o  o          level 1
           /\   \
          o  o   \        level 2
         /\  /\   \
        1 2 3  4   5      level 3

For example, if there are 5 transactions (tx), the merkle tree would look like above.
Numbers are index of tx (leaves), circles are hashes, `[root]` is Merkle root.

If one obtain a `tx2'` hash which claimed to be the `tx2` in the tree,
then one can use `merkleTree.validateProof(proof, target, merkleRoot)` to validate whether `tx2'` is in the tree or not.
The arguments are: 

* `proof`: hash of `1`, hash of `hash(3)+hash(4)` in level 2, and hash of 5
    - these proofs can be generated by `merkleTree.getProof(2)`
* `target`: the hash of `tx2'`
* `merkleRoot`: the correct merkle root
